---
title: "Milestone 3"
author: "Ruth Zheng"
date: "2/23/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Paper Summary

In the paper, \textit{When Do Renters Behave Like Homeowners? High Rent, Price Anxiety, and NIMBYism}, Michael Hankinson performs a quantitative analysis of NIMBYism applied to trends in local housing markets. Asking the question of what drives homeowners and renters to embrace NIMBY attitudes towards housing, the paper draws upon two original data sets: the first an exit-poll survey of politically active San Francisco voters in a municipal election and the second a nation-wide set of survey data. The paper first finds that in the San Francisco sset, renters more often than homeowners, indicated that they would support a ban on the creation of new housing. This is a surprising result because one would expect renters to support new housing as greater supply will drive prices down -- this is good for renters, but bad for homeowners. Hankinson suspects this discrepancy is due to a fear of gentrification, that new developments will attract even greater demand causing renters to be priced out of their homes. The second part of the paper analyzes the nationwide data from a survey that was cleverly constructed to offer random combinations of several significant attributes of hypothetical new housing developments (such as stories, rent v. own, distance from ones own neighborhood, etc.) to respondants who were then asked to indicate whether they would support such a development. This allowed Hankinson to isolate specific attributes and quantify their effects on attitudes towards new housing. This part first finds that distance to the respondant's neighborhood has a significant and negative relationship to opposing new housing, confirming the NIMBYism theory. It then analyzes a separate question on the survey that attempted to guage respondant's level of price anxiety (fear that neighborhood prices would rise, i.e. fear of gentrification). The paper found that high price anxiety renters had a significantly higher tendency to oppose new housing developments, thus resolving the earlier discrepancy. Indeed renters do behave like homeowners when they live in high price neighborhoods and fear rising prices. 


## Code with Comments

*Note: my own comments begin with three \#'s

```{r}

###First he loads a bunch of packages. Are tidyr and plyr the same as tidyverse and dplyr? 

library(tidyr)
library(car)
library(robustHD)
library(stargazer)
library(foreign)
library(sandwich)
library(grid)
library(lmtest)
library(ggplot2)
library(plyr)
library(RColorBrewer)
library(cjoint)
library(multiwayvcov)
library(coefplot)

########################################
#### National Survey - Non-Conjoint
########################################

setwd("/Users/Michael/Dropbox/apsr")

### He reads the data and splits renters and owners into two subgroups by subsetting. 

#bring in data
socpoc<-read.csv("data/socpocAPSR.csv", stringsAsFactors = F)

#assign ownership groups
renters<-subset(socpoc, own==0)
owners<-subset(socpoc, own==1)

### He calculates the percentage of renters and homeowners who would support a 10% increase in housing. 

#10% supply support models 
table(renters$supply_dummy)
352/(247+352) #.59
table(owners$supply_dummy)
361/(949+361) #.28

### He performs a simple regression of support for a 10% supply increase on home ownership.

# Table B.2. Support for 10 Percent Supply Increase ####
## bivariate
supply_simple<-(lm(supply_dummy ~ own, socpoc));summary(supply_simple)

### He performs the same regression but this time uses a 7-point scale of support ("strongly oppose" to "strongly support") rather than the binary response variable.
### He then takes calculates the standard error by calling the variance co-variance matrix. 

# Table B.3. Support for 10 Percent Supply Increase - 7 Point Scale ####
## bivariate
supply_7_simple<-(lm(city_supply ~ own, socpoc));summary(supply_7_simple)
supply_7_simple_se<-sqrt(diag(vcovHC(supply_7_simple, type="HC1")))

### He performs a full regression of categorical support variable on all covariates and calculates the standard errors for each variable. 

# full
supply_7_full<-(lm(city_supply ~ own +scale(ideology)+scale(log(income)) + whitenh  +age + male, subset(socpoc)));summary(supply_7_full)
supply_7_full_se<-sqrt(diag(vcovHC(supply_7_full, type="HC1")))

### He performs the full regression with municipal fixed effects and pulls out the standard errors. 

#full w/ fixed effects
supply_7_full_fe<-(lm(city_supply ~  own +scale(ideology)+ scale(log(income))+ whitenh  + age + male +factor(name), socpoc));summary(supply_7_full_fe)
supply_7_full_fe_se<-sqrt(diag(vcovHC(supply_7_full_fe, type="HC1")))

### He creates a table; this is table B.3 in the paper appendix. 

# Table
stargazer(supply_7_simple,  supply_7_full , supply_7_full_fe, title="Support for 10 Percent Supply Increase - 7 Point Scale", label="supply_7",
          dep.var.labels=c("Support Supply Increase"),dep.var.labels.include = F, dep.var.caption = "",
          column.labels=c("Bivariate","Full","Full with Fixed Effects"),
          covariate.labels=c("Homeownership","Ideology","Income, Log","White, Non-Hispanic","Age","Male"),
          omit.stat = c("ser", "f"), digits=2, align=T, type="text",
          initial.zero = F,  font.size = "small", star.cutoffs = NA, omit.table.layout = "n",
          se=list(supply_7_simple_se, supply_7_full_se, supply_7_full_fe_se), no.space=T,omit=c("name"))

### He creates a plot showing spread of support for the 10% increase based on average city rent, divided into quintiles. 

# Figure 6. Renter Support for Supply Citywide, by Average City Rent ####

### He divides the data into quintiles using the quantile function.

quantile(socpoc$zri_city, probs=seq(0,1,.2), na.rm=T)

### He creates empty vectors for the estimate and the standard error of support in each quintile. 

zri_city_values<-c(0,1217,1480,1936,2427,7344)
est1<-rep(NA, length(zri_city_values))
se1<-rep(NA, length(zri_city_values))

### He loops through each quintile to calculate the expected value and the standard error of support (still using categorical response).

for(i in 1:5){
  section<-subset(renters, zri_city>zri_city_values[i] & zri_city<=zri_city_values[i+1])
  est1[i]<-mean(section$supply_dummy,na.rm=T)
  se1[i]<-sqrt((est1[i]*(1-est1[i]))/nrow(section))
}

### He combines the above vectors into a dataframe, to get ready to plot. 

mod1ests<-as.data.frame(cbind(zri_city_values,est1,se1))

### He calculates a 95% confidence interval for the estimates. 

mod1ests$uCI<-est1+se1*1.96
mod1ests$lCI<-est1-se1*1.96

### He builds a the data frame, renames the columns, and imputes values calculated from above. 

mod1estimates<-mod1ests[1:5,]
colnames(mod1estimates)<-c("Rent","Estimate", "StdErr", "UpperCI", "LowerCI")
mod1estimates$Quintile<-c(1,2,3,4,5)
mod1estimates
mod1estimates$Cost<-factor(c("Least Expensive","2nd","3rd","4th","Most Expensive"))
levels(mod1estimates$Cost)
pd <- position_dodge(0.1)
mod1estimates$Cost <- factor(mod1estimates$Cost, levels = c("Least Expensive","2nd","3rd","4th","Most Expensive"))
mod1estimates

### He uses the ggplot function to plot the distributions of support for each price quintile. 

renter_city_supply<-ggplot(mod1estimates, aes(x=Cost, y=Estimate))+scale_y_continuous(limits = c(0, 1))+coord_flip()+
  geom_errorbar(aes(ymin=LowerCI, ymax=UpperCI), width=.1, position=pd) +
  geom_point(position=pd)+  labs(x = "Average City Rent (Quintiles)", y="Support for Supply (%)")+ggtitle("Renters Support for Supply Citywide, by Average Rent") + theme(aspect.ratio = .5)+
  theme_bw()+scale_fill_grey()
pdf("plots/Fig6_renters_city_supply.pdf", width=6, height=3)
print(renter_city_supply)
dev.off()

### He uses the tiff function to improve the resolution and quality of the plot. 

tiff("plots/Fig6_renters_city_supply.tif", res=600, compression="lzw", height=3, width=6, units="in")
print(renter_city_supply)
dev.off()

### He creates figure C8 in the paper, showing renters support for increasing supply based on rent. 

# Figure C.8. Renters Suppport for Supply Cityiwde, Average ZIP Rent ####

### He divides the data into quintiles based on home prices. 

quantile(socpoc$zri, probs=seq(0,1,.2), na.rm=T)
zri_city_values<-c(0,1204,1526,1958,2488,13000)

### He creates empty vectors for estimates and standard errors.

est1<-rep(NA, length(zri_city_values))
se1<-rep(NA, length(zri_city_values))

### He uses a for loop to calculate estimated support for each quintile and the standard error. 

for(i in 1:5){
  section<-subset(renters, zri>zri_city_values[i] & zri<=zri_city_values[i+1])
  est1[i]<-mean(section$supply_dummy,na.rm=T)
  se1[i]<-sqrt((est1[i]*(1-est1[i]))/nrow(section))
}

### He combines the vectors into a dataframe and calculates a 95% confidence interval. 

mod1ests<-as.data.frame(cbind(zri_city_values,est1,se1))
mod1ests$uCI<-est1+se1*1.96
mod1ests$lCI<-est1-se1*1.96

### He creates a nicer data frame in order to plot, using the correct labels and imputing all desired values. 

mod1estimates<-mod1ests[1:5,]
colnames(mod1estimates)<-c("Rent","Estimate", "StdErr", "UpperCI", "LowerCI")
mod1estimates$Quintile<-c(1,2,3,4,5)
mod1estimates
mod1estimates$Cost<-factor(c("Least Expensive","2nd","3rd","4th","Most Expensive"))
levels(mod1estimates$Cost)
pd <- position_dodge(0.1)
mod1estimates$Cost <- factor(mod1estimates$Cost, levels = c("Least Expensive","2nd","3rd","4th","Most Expensive"))
mod1estimates

### He creates the plot using ggplot of estimated support level for each quintile with a 95% confidence band. 

renter_zip_supply<-ggplot(mod1estimates, aes(x=Cost, y=Estimate))+scale_y_continuous(limits = c(0, 1))+coord_flip()+
  geom_errorbar(aes(ymin=LowerCI, ymax=UpperCI), width=.1, position=pd) +
  geom_point(position=pd)+  labs(x = "Average ZIP Rent (Quintiles)", y="Support for Supply (%)")+ggtitle("Renters Support for Supply Citywide, by Average ZIP Rent") + theme(aspect.ratio = .5)+
  theme_bw()+scale_fill_grey()
pdf("plots/FigC8_renters_zip_supply.pdf", width=6, height=3)
print(renter_zip_supply)
dev.off()

### He uses tiff to make the graphic higher resolution. 

tiff("plots/FigC8_renters_zip_supply.tif", res=600, compression="lzw", height=3, width=6, units="in")
print(renter_zip_supply)
dev.off()

### He creates Figure C9 in the paper appendex showing homeowners support for increased housing based on price of homes. 

# Figure C.9. Homeowners Support for Supply Citywide, Average City Rent ####

### HE uses the quantile function to split the data into quintiles. 

quantile(socpoc$zri_city, probs=seq(0,1,.2), na.rm=T)
zri_city_values<-c(0,1217,1480,1936,2427,7344)

### He creates empty vectors and loops through each quintile to find the estimated support and standard error. 

est2<-rep(NA, length(zri_city_values))
se2<-rep(NA, length(zri_city_values))

for(i in 1:5){
  section<-subset(owners, zri_city>zri_city_values[i] & zri_city<=zri_city_values[i+1])
  est2[i]<-mean(section$supply_dummy,na.rm=T)
  se2[i]<-sqrt((est2[i]*(1-est2[i]))/nrow(section))
}

### He calculates a 95% confidence interval 

mod2ests<-as.data.frame(cbind(zri_city_values,est2,se2))
mod2ests$uCI<-est2+se2*1.96
mod2ests$lCI<-est2-se2*1.96

### He combines results into a data frame with the appropriate labels and imputes corresponding values. 

mod2estimates<-mod2ests[1:5,]
colnames(mod2estimates)<-c("Rent","Estimate", "StdErr", "UpperCI", "LowerCI")
mod2estimates$Quintile<-c(1,2,3,4,5)
mod2estimates
mod2estimates$Cost<-factor(c("Least Expensive","2nd","3rd","4th","Most Expensive"))
levels(mod2estimates$Cost)
pd <- position_dodge(0.1)
mod2estimates$Cost <- factor(mod2estimates$Cost, levels = c("Least Expensive","2nd","3rd","4th","Most Expensive"))

### He uses ggplot to plot create the plot of estimated support level for each quintile with a 95% confidence band. 

owners_city_supply<-ggplot(mod2estimates, aes(x=Cost, y=Estimate))+scale_y_continuous(limits = c(0, 1))+coord_flip()+
  geom_errorbar(aes(ymin=LowerCI, ymax=UpperCI), width=.1, position=pd) +
  geom_point(position=pd)+ggtitle("Homeowners Support for Supply Citywide, by Average Rent")+
  labs(x = "Average City Rent (Quintiles)", y="Support for Supply (%)")+ theme(aspect.ratio=.5)+
  theme_bw()+scale_fill_grey()
pdf("plots/FigC9_owners_city_supply.pdf", width=6, height=3)
print(owners_city_supply)
dev.off()

### He uses tiff to improve the image quality. 

tiff("plots/FigC9_owners_city_supply.tif", res=600, compression="lzw", height=3, width=6, units="in")
print(owners_city_supply)
dev.off()

### He creates Figure 3 in the supplementary material section. 

# Supplmentary Figure 3. Homeowners Support for Supply Citywide, Average ZIP Rent ####

### He divides data into quintiles based on zip code rent. 

quantile(socpoc$zri, probs=seq(0,1,.2), na.rm=T)
zri_city_values<-c(0,1204,1526,1958,2488,13000)

### He creates empty vectors for estimations and standard errors and loops through each quintile to calculate them. 

est2<-rep(NA, length(zri_city_values))
se2<-rep(NA, length(zri_city_values))

for(i in 1:5){
  section<-subset(owners, zri>zri_city_values[i] & zri<=zri_city_values[i+1])
  est2[i]<-mean(section$supply_dummy,na.rm=T)
  se2[i]<-sqrt((est2[i]*(1-est2[i]))/nrow(section))
}

### He calculates a 95% confidence interval.

mod2ests<-as.data.frame(cbind(zri_city_values,est2,se2))
mod2ests$uCI<-est2+se2*1.96
mod2ests$lCI<-est2-se2*1.96

### He combines this into a data frame and names the columns and imputes the calculated values. 

mod2estimates<-mod2ests[1:5,]
colnames(mod2estimates)<-c("Rent","Estimate", "StdErr", "UpperCI", "LowerCI")
mod2estimates$Quintile<-c(1,2,3,4,5)
mod2estimates
mod2estimates$Cost<-factor(c("Least Expensive","2nd","3rd","4th","Most Expensive"))
levels(mod2estimates$Cost)
pd <- position_dodge(0.1)
mod2estimates$Cost <- factor(mod2estimates$Cost, levels = c("Least Expensive","2nd","3rd","4th","Most Expensive"))

### He plots using ggplot a graph of support with a 95% confidence band for each quintile. 

owners_zip_supply<-ggplot(mod2estimates, aes(x=Cost, y=Estimate))+scale_y_continuous(limits = c(0, 1))+coord_flip()+
  geom_errorbar(aes(ymin=LowerCI, ymax=UpperCI), width=.1, position=pd) +
  geom_point(position=pd)+ggtitle("Homeowners Support for Supply Citywide, by Average ZIP Rent")+
  labs(x = "Average ZIP Rent (Quintiles)", y="Support for Supply (%)")+ theme(aspect.ratio=.5)+
  theme_bw()+scale_fill_grey()
pdf("plots/FigSupp3_owners_zip_supply.pdf", width=6, height=3)
print(owners_zip_supply)
dev.off()

### He uses tiff to imrpove image resolution. 

tiff("plots/FigSupp3_owners_zip_supply.tif", res=600, compression="lzw", height=3, width=6, units="in")
print(owners_zip_supply)
dev.off()

### He calculates the number of renters and owners respectively that support a ban on new housing 

#### Nimby ban models 
table(renters$ban_dummy)
234/(234+434) #.35
table(owners$ban_dummy)
593/(811+593) #.42

### He regresses a binary variable for supporting the ban on homeownership status. 

# Table B.4. Support for Neighborhood Ban ####
## bivariate
ban_simple<-(lm(ban_dummy ~ own, socpoc));summary(ban_simple)
ban_simple_se<-sqrt(diag(vcovHC(ban_simple, type="HC1")))

### He fits a full linear model including all covariates. 

# full
ban_full<-(lm(ban_dummy ~ own +scale(ideology)+scale(log(income)) + whitenh  +age + male, socpoc));summary(ban_full)
ban_full_se<-sqrt(diag(vcovHC(ban_full, type="HC1")))

### He fits a full linear model with the same response variable and covariates but includes fixed effects for municipality. 

#full w/ fixed effects
ban_full_fe<-(lm(ban_dummy ~  own +scale(ideology)+ scale(log(income))+ whitenh  + age + male +factor(name), socpoc));summary(ban_full_fe)
ban_full_fe_se<-sqrt(diag(vcovHC(ban_full_fe, type="HC1")))

### He creates  table of regression results for simple, full, and full with fixed effects. 

# Table
stargazer(ban_simple,  ban_full , ban_full_fe, title="Support for Ban on Neighborhood Development", label="ban_dummy",
          dep.var.labels=c("Support NIMBY Ban"),dep.var.labels.include = F, dep.var.caption = "",
          column.labels=c("Bivariate","Full","Full with Fixed Effects"),
          covariate.labels=c("Homeownership","Ideology","Income, Log","White, Non-Hispanic","Age","Male"),
          omit.stat = c("ser", "f"), digits=2, align=T, type="text",
          initial.zero = F,  font.size = "small",star.cutoffs = NA, omit.table.layout = "n",
          se=list(ban_simple_se, ban_full_se, ban_full_fe_se), no.space=T, omit=c("name"))

### He runs a regression of the 7 point response variable onto home ownership status 

# Table B.5. Support for Neighborhood Ban 7 point scale ####
#simple
ban_simple<-(lm(neighborhood_ban ~ own, socpoc));summary(ban_simple)
ban_simple_se<-sqrt(diag(vcovHC(ban_simple, type="HC1")))


### He runs the full model by including other covariates. 

# full
ban_full<-(lm(neighborhood_ban ~ own +scale(ideology)+scale(log(income)) + whitenh  +age + male, socpoc));summary(ban_full)
ban_full_se<-sqrt(diag(vcovHC(ban_full, type="HC1")))

### He runs the same full model and adds municipal fixed effects. 

#full w/ fixed effects
ban_full_fe<-(lm(neighborhood_ban ~  own +scale(ideology)+ scale(log(income))+ whitenh  + age + male +factor(name), socpoc));summary(ban_full_fe)
ban_full_fe_se<-sqrt(diag(vcovHC(ban_full_fe, type="HC1")))

### He creates a table of the coefficients from the simple, full, and full with fixed effects model. 

# Table
stargazer(ban_simple,  ban_full , ban_full_fe, title="Support for Ban on Neighborhood Development - 7 Point Scale", label="neighborhood_ban_7",
          dep.var.labels=c("Support NIMBY Ban"),dep.var.labels.include = F, dep.var.caption = "",
          column.labels=c("Bivariate","Full","Full with Fixed Effects"),
          covariate.labels=c("Homeownership","Ideology","Income, Log","White, Non-Hispanic","Age","Male"),
          omit.stat = c("ser", "f"), digits=2, align=T, type="text",
          initial.zero = F,  font.size = "small",star.cutoffs = NA, omit.table.layout = "n",
          se=list(ban_simple_se, ban_full_se, ban_full_fe_se), no.space=T, omit=c("name"))

### This is on the national survey data with a conjoint experiment on whether respondants would support a specific new building.

####################################
#### National Survey - Conjoint 
####################################

setwd("/Users/Michael/Dropbox/apsr")

### He reads in the data

conjoint4<-read.csv("data/conjointDataAPSR.csv")
table(conjoint4$own)

### He relevels the data back into factors for each random characteristic he draws upon in the experiment.  

#relevel
conjoint4$distance <- factor(conjoint4$distance,levels= c("2 miles (40 minute walk)", "1 mile (20 minute walk)", "1/2 mile (10 minute walk)","1/8 mile (2 minute walk)"))
conjoint4$community <- factor(conjoint4$community,levels= c("No opinion", "Support the building", "Oppose the building"))
conjoint4$affordable <- factor(conjoint4$affordable,levels= c("None of the units", "One-quarter of the units", "Half of the units", "All of the units"))
conjoint4$height <- factor(conjoint4$height,levels= c("2 stories", "3 stories", "6 stories", "12 stories"))
conjoint4$site <- factor(conjoint4$site, levels=c("Empty building","Parking lot","Open field","Historically-designated building"))
names(conjoint4)
#reclassify items as factor
cols<-c("own", "whitenh", "nearby","conjoint_first","rich", "luxury")

conjoint4[cols] <- data.frame(apply(conjoint4[c(cols)], 2, as.factor))

### He creates dummy variables for being liberal and having low city interest. 

# dummies
conjoint4$liberal<-as.factor(ifelse(conjoint4$ideology>4,1,ifelse(conjoint4$ideology<4,0, NA)))
conjoint4$city_interest_low<-as.factor(ifelse(conjoint4$city_interest<0,1,0))

### He also creates dummy variables for ownership and renters. 

#define subgroups/dummies
renters<-subset(conjoint4, own==0)
owners<-subset(conjoint4, own==1)

### He divides both owners and renters into groups based on whether they live in affordable housing. 

#define affordability levels
renters_aff<-subset(renters, aff_housing==1)
renters_lux<-subset(renters, aff_housing==0)

owners_aff<-subset(owners, aff_housing==1)
owners_lux<-subset(owners, aff_housing==0)

### This next code section pertains to creating the table for effect of proximity on probability of preferring the new building.

# FIGURE 3. Homeowners, Proximity by Affordability ####

### He regresses selecting yes on the hypothetical building to the six factors specified for the two groups of homeowners created above. 

owners_luxury_mod<-amce(select ~ distance  + community + height + site + tenant + units,
                        data= owners_lux , cluster=T,  respondent.id = "CaseID")
owners_affordable_mod<-amce(select ~ distance  + community + height + site + tenant + units,
                            data=owners_aff, cluster=T,  respondent.id = "CaseID")

### He extracts the coefficients and standard errors into dataframes for affordable and luxury price level owners, builds data frames.   

owners_luxury_mod_frame<-data.frame(Variable=(summary(owners_luxury_mod)$amce)$Level,
                                    Coefficient = (summary(owners_luxury_mod)$amce)$Estimate,
                                    SE=(summary(owners_luxury_mod)$amce)$'Std. Err',
                                    modelName="Market Rate")
owners_affordable_mod_frame<-data.frame(Variable=(summary(owners_affordable_mod)$amce)$Level,
                                        Coefficient = (summary(owners_affordable_mod)$amce)$Estimate,
                                        SE=(summary(owners_affordable_mod)$amce)$'Std. Err',
                                        modelName="Affordable")
ownersPriceFrame<-data.frame(rbind(owners_luxury_mod_frame, owners_affordable_mod_frame))
ownersPriceFrame<-subset(ownersPriceFrame, Variable=="1/8 mile (2 minute walk)"|Variable=="1/2 mile (10 minute walk)"|Variable=="1 mile (20 minute walk)")
ownersPriceFrameIntercepts<-data.frame(Variable=c("2 miles (40 minute walk)", "2 miles (40 minute walk)") ,Coefficient=c(0,0), SE=c(0,0), modelName=c("Market Rate", "Affordable"))
ownersPriceFrame<-data.frame(rbind(ownersPriceFrame,ownersPriceFrameIntercepts))

### He calculates a 90% and a 95% confidnece interval 

interval1<-qnorm((1-.9)/2)
interval2<-qnorm((1-.95)/2)

### He renames the factor levels for distance to get ready to plot. 

ownersPriceFrame$Variable <- factor(ownersPriceFrame$Variable, levels = c("1/8 mile (2 minute walk)","1/2 mile (10 minute walk)", "1 mile (20 minute walk)", "2 miles (40 minute walk)"))

### He uses ggplot to plots probability of support for each distance level with a 90% confidence interval. Each line represents adding in one level. 

owners_price_nimby<-ggplot(ownersPriceFrame, aes(colour=modelName, shape=modelName))+ scale_y_continuous(limits = c(-.20, .20))
owners_price_nimby<-owners_price_nimby+theme_bw()+scale_colour_grey(end=.5)+geom_hline(yintercept=0, colour=gray(1/2), lty=2)
owners_price_nimby<-owners_price_nimby+geom_linerange(aes(x=Variable, ymin=Coefficient-SE*interval1, 
                                                          ymax=Coefficient+SE*interval1), lwd=1, position=position_dodge(width=1/2))
owners_price_nimby<-owners_price_nimby+geom_pointrange(aes(x=Variable, y=Coefficient, ymin=Coefficient-SE*interval2,
                                                           ymax=Coefficient+SE*interval2), lwd=1/2,
                                                       position=position_dodge(width=1/2), fill="WHITE")
owners_price_nimby<-owners_price_nimby+coord_flip()+labs(y="Change in Probability Building Preferred")
owners_price_nimby<-owners_price_nimby+theme(legend.title=element_blank(),axis.title.y=element_blank())+ theme(aspect.ratio = .5)
owners_price_nimby<-owners_price_nimby+theme(plot.margin=unit(c(0,0,0,0),"mm"))+ggtitle("Homeowners, Proximity by Affordability") + guides(colour=guide_legend(reverse=T), shape=guide_legend(reverse=T))
pdf("plots/Fig3_owners_price_nimby.pdf", width=6, height=3)
print(owners_price_nimby)
dev.off()

### He uses tiff to improve the image quality. 

tiff("plots/Fig3_owners_price_nimby.tif", res=600, compression="lzw", height=3, width=6, units="in")
print(owners_price_nimby)
dev.off()

### He repeats the process above for renters. 

# FIGURE 4. Renters, Proximity by Affordability ####
renters_luxury_mod<-amce(select ~ distance  + community + height + site + tenant + units,
                         data= renters_lux , cluster=T,  respondent.id = "CaseID")
renters_affordable_mod<-amce(select ~ distance  + community + height + site + tenant + units,
                             data=renters_aff, cluster=T,  respondent.id = "CaseID")
renters_luxury_mod_frame<-data.frame(Variable=(summary(renters_luxury_mod)$amce)$Level,
                                     Coefficient = (summary(renters_luxury_mod)$amce)$Estimate,
                                     SE=(summary(renters_luxury_mod)$amce)$'Std. Err',
                                     modelName="Market Rate")
renters_affordable_mod_frame<-data.frame(Variable=(summary(renters_affordable_mod)$amce)$Level,
                                         Coefficient = (summary(renters_affordable_mod)$amce)$Estimate,
                                         SE=(summary(renters_affordable_mod)$amce)$'Std. Err',
                                         modelName="Affordable")
rentersPriceFrame<-data.frame(rbind(renters_luxury_mod_frame, renters_affordable_mod_frame))
rentersPriceFrame<-subset(rentersPriceFrame, Variable=="1/8 mile (2 minute walk)"|Variable=="1/2 mile (10 minute walk)"|Variable=="1 mile (20 minute walk)")
rentersPriceFrameIntercepts<-data.frame(Variable=c("2 miles (40 minute walk)", "2 miles (40 minute walk)") ,Coefficient=c(0,0), SE=c(0,0), modelName=c("Market Rate", "Affordable"))
rentersPriceFrame<-data.frame(rbind(rentersPriceFrame,rentersPriceFrameIntercepts))
interval1<-qnorm((1-.9)/2)
interval2<-qnorm((1-.95)/2)
rentersPriceFrame$Variable <- factor(rentersPriceFrame$Variable, levels = c("1/8 mile (2 minute walk)","1/2 mile (10 minute walk)", "1 mile (20 minute walk)", "2 miles (40 minute walk)"))
renters_price_nimby<-ggplot(rentersPriceFrame, aes(colour=modelName, shape=modelName)) + scale_y_continuous(limits = c(-.20, .20))
renters_price_nimby<-renters_price_nimby+theme_bw()+scale_colour_grey(end=.5)+geom_hline(yintercept=0, colour=gray(1/2), lty=2)
renters_price_nimby<-renters_price_nimby+geom_linerange(aes(x=Variable, ymin=Coefficient-SE*interval1, 
                                                            ymax=Coefficient+SE*interval1), lwd=1, position=position_dodge(width=1/2))
renters_price_nimby<-renters_price_nimby+geom_pointrange(aes(x=Variable, y=Coefficient, ymin=Coefficient-SE*interval2,
                                                             ymax=Coefficient+SE*interval2), lwd=1/2,
                                                         position=position_dodge(width=1/2), fill="WHITE")
renters_price_nimby<-renters_price_nimby+coord_flip()+ labs(y="Change in Probability Building Preferred")
renters_price_nimby<-renters_price_nimby+theme(legend.title=element_blank(), axis.title.y=element_blank())+ theme(aspect.ratio = .5)
renters_price_nimby<-renters_price_nimby+theme(plot.margin=unit(c(0,0,0,0),"mm")) +ggtitle("Renters, Proximity by Affordability")+ guides(colour=guide_legend(reverse=T), shape=guide_legend(reverse=T))
pdf("plots/Fig4_renters_price_nimby.pdf", width=6, height=3)
print(renters_price_nimby)
dev.off()

tiff("plots/Fig4_renters_price_nimby.tif", res=600, compression="lzw", height=3, width=6, units="in")
print(renters_price_nimby)
dev.off()

### This next section pertains to calculating renters behaving like homeowners (exhibiting NIMBYism) based on price levels int heir neighborhoods

# FIGURE 5, Renters, Nimby by Affordability, Quintile City####

### He divides the set into quintiles based on city rent values. 

quantile(conjoint4$zri_city, probs=seq(0,1,.1), na.rm=T) # define quintiles

### He defines the quintiles.

zri_city_values<-c(0,1217,1480,1936,2427,7344)

### He creates empty vectors for estimates and a standard error for each quintile 

est1<-rep(NA, length(zri_city_values))
se1<-rep(NA, length(zri_city_values))

### He loops to regress probability of selecting yes to the new establishment onto all specificed factors.
### He extracts the coefficient for distance and its relevant standard error. 

for(i in 1:5){
  
### This model has clustered standard errors, this is also for the high price level renters. 
  
  mod1<-amce(select ~ distance+ community + height + site + tenant + units,
             data=subset(renters, zri_city>zri_city_values[i] & zri_city<=zri_city_values[i+1]&luxury==1), cluster=T, respondent.id = "CaseID")
  est1[i]<-summary(mod1)$amce[5,3]
  se1[i]<-summary(mod1)$amce[5,4]
}

### He binds the results into a new data frame

mod1ests<-as.data.frame(cbind(zri_city_values,est1,se1))

### He calculates a 95%confidence interval. 

mod1ests$uCI<-est1+se1*1.96
mod1ests$lCI<-est1-se1*1.96

### He repeats the above process but this time for lower price level renters (more affordable prices). 

est2<-rep(NA, length(zri_city_values))
se2<-rep(NA, length(zri_city_values))
for(i in 1:5){
  mod2<-amce(select ~ distance+ community + height + site + tenant + units,
             data=subset(renters, zri_city>zri_city_values[i] & zri_city<=zri_city_values[i+1]&luxury==0), cluster=T, respondent.id = "CaseID")
  est2[i]<-summary(mod2)$amce[5,3]
  se2[i]<-summary(mod2)$amce[5,4]
}
mod2ests<-as.data.frame(cbind(zri_city_values,est2,se2))
mod2ests$uCI<-est2+se2*1.96
mod2ests$lCI<-est2-se2*1.96

### He combines the data from two loops above. 
### This requires re-naming columns and levels which he does here. 

#combine data
mod1<-mod1ests[-6,]
mod1$quintle<-c("Least Expensive","2nd","3rd","4th","Most Expensive")
mod1$modelName<-"Market Rate"
names(mod1)<-c("zri","est","se","uci","lci","Quintile","modelName")
mod2<-mod2ests[-6,]
mod2$quintle<-c("Least Expensive","2nd","3rd","4th","Most Expensive")
mod2$modelName<-"Affordable"
names(mod2)<-c("zri","est","se","uci","lci","Quintile","modelName")

### He combines the results for affordable and luxury renters. 

modFrame<-data.frame(rbind(mod1,mod2))

### He converts the quintile numerical values into a factor.

modFrame$Quintile <- factor(modFrame$Quintile, levels = c("Least Expensive", "2nd","3rd", "4th", "Most Expensive"))

### He calculates "T" (not really T obviously) values for 90% and 95% confidence intervals. 

interval1<-qnorm((1-.9)/2)
interval2<-qnorm((1-.95)/2)
modFrame
modFrame$modelName<-factor(modFrame$modelName, levels=c("Market Rate","Affordable"))

### He uses ggplot to create the plot of estimates for probability based on price of rent

renters_type_nimby<-ggplot(modFrame, aes(colour=modelName, shape=modelName))+ scale_y_continuous(limits = c(-.25, .25))
renters_type_nimby<-renters_type_nimby+theme_bw()+scale_colour_grey(end=.5)+geom_hline(yintercept=0, colour=gray(1/2), lty=2)
renters_type_nimby<-renters_type_nimby+geom_linerange(aes(x=Quintile, ymin=est-se*interval1, 
                                                          ymax=est+se*interval1), lwd=1, position=position_dodge(width=1/2))
#+scale_color_manual(values=c('#F8766D', '#00BFC4'))

renters_type_nimby<-renters_type_nimby+geom_pointrange(aes(x=Quintile, y=est, ymin=est-se*interval2,
                                                           ymax=est+se*interval2), lwd=1/2,
                                                       position=position_dodge(width=1/2),  fill="WHITE")
renters_type_nimby<-renters_type_nimby+coord_flip()+ labs(y="Change in Probability Building Preferred",x="Average Rent by City (Quintiles)")
renters_type_nimby<-renters_type_nimby+theme(legend.title=element_blank()) + theme(aspect.ratio = .5)
renters_type_nimby<-renters_type_nimby+theme(plot.margin=unit(c(0,0,0,0),"mm"))+ ggtitle("Renters, Proximity by Affordability and Average Rent by City") +guides(colour=guide_legend(reverse=T), shape=guide_legend(reverse=T))
pdf("plots/Fig5_renters_type_nimby.pdf", width=6, height=3)
print(renters_type_nimby)
dev.off()

### He uses tiff 

tiff("plots/Fig5_renters_type_nimby.tif", res=600, compression="lzw", height=3, width=6, units="in")
print(renters_type_nimby)
dev.off()

### This section looks at specifically the price anixiety hypothesis. 

# FIGURE 7, Renters, nimby by price anxiety ####

### He fits a model for luxury renders of probability of selecting based on the relevant qualities. 

renters_city_low_mod<-amce(select ~ distance  + community + height + site + tenant + units,
                           data=subset(renters_lux, city_interest<0) , cluster=T,  respondent.id = "CaseID")
renters_city_high_mod<-amce(select ~ distance  + community + height + site + tenant + units,
                            data=subset(renters_lux, city_interest>=0), cluster=T,  respondent.id = "CaseID")

### He putes the rest into a data frame according to price neutral and price anxious based on whether or not they are interested in price levels decreasing in their city. 

renters_city_low_mod_frame<-data.frame(Variable=(summary(renters_city_low_mod)$amce)$Level,
                                       Coefficient = (summary(renters_city_low_mod)$amce)$Estimate,
                                       SE=(summary(renters_city_low_mod)$amce)$'Std. Err',
                                       modelName="Price Anxious")
renters_city_high_mod_frame<-data.frame(Variable=(summary(renters_city_high_mod)$amce)$Level,
                                        Coefficient = (summary(renters_city_high_mod)$amce)$Estimate,
                                        SE=(summary(renters_city_high_mod)$amce)$'Std. Err',
                                        modelName="Price Neutral")

### He combines the above two data frames. 

rentersCityFrame<-data.frame(rbind(renters_city_low_mod_frame, renters_city_high_mod_frame))
rentersCityFrame<-subset(rentersCityFrame, Variable=="1/8 mile (2 minute walk)"|Variable=="1/2 mile (10 minute walk)"|Variable=="1 mile (20 minute walk)")

### He adds intercepts to the dataframe. 

rentersCityFrameIntercepts<-data.frame(Variable=c("2 miles (40 minute walk)", "2 miles (40 minute walk)") ,Coefficient=c(0,0), SE=c(0,0), modelName=c("Price Anxious", "Price Neutral"))
rentersCityFrame<-data.frame(rbind(rentersCityFrame,rentersCityFrameIntercepts))

### He uses normal quantiles to generate values for calculating confidence itnervals 

interval1<-qnorm((1-.9)/2)
interval2<-qnorm((1-.95)/2)
rentersCityFrame$Variable <- factor(rentersCityFrame$Variable, levels = c("1/8 mile (2 minute walk)","1/2 mile (10 minute walk)", "1 mile (20 minute walk)", "2 miles (40 minute walk)"))

### HE uses ggplot to plot the above data frame

renters_anxious_nimby<-ggplot(rentersCityFrame, aes(colour=modelName, shape=modelName))+ scale_y_continuous(limits = c(-.25, .25))
renters_anxious_nimby<-renters_anxious_nimby+theme_bw()+scale_colour_grey(end=.5)+geom_hline(yintercept=0, colour=gray(1/2), lty=2)+scale_shape_manual(values=c(4,5))
#+ scale_color_manual(values=c('#990099','#33CC00'))
renters_anxious_nimby<-renters_anxious_nimby+geom_linerange(aes(x=Variable, ymin=Coefficient-SE*interval1, 
                                                                ymax=Coefficient+SE*interval1), lwd=1, position=position_dodge(width=1/2))
renters_anxious_nimby<-renters_anxious_nimby+geom_pointrange(aes(x=Variable, y=Coefficient, ymin=Coefficient-SE*interval2,
                                                                 ymax=Coefficient+SE*interval2), lwd=1/2,
                                                             position=position_dodge(width=1/2), fill="WHITE")
renters_anxious_nimby<-renters_anxious_nimby+coord_flip()+ labs(y="Change in Probability Building Preferred")
renters_anxious_nimby<-renters_anxious_nimby+theme(legend.title=element_blank(),axis.title.y=element_blank())+theme(aspect.ratio = .5)
renters_anxious_nimby<-renters_anxious_nimby+theme(plot.margin=unit(c(0,0,0,0),"mm")) + ggtitle("Renters, Proximity by Price Anxiety (Market Rate)")+ theme(aspect.ratio = .5)+ guides(colour=guide_legend(reverse=T), shape=guide_legend(reverse=T))
pdf("plots/Fig7_renters_anxious_nimby.pdf", width=6, height=3)
print(renters_anxious_nimby)
dev.off()

tiff("plots/Fig7_renters_anxious_nimby.tif", res=600, compression="lzw", height=3, width=6, units="in")
print(renters_anxious_nimby)
dev.off()


######################
#### SF EXIT POLL 
######################

setwd("/Users/Michael/Dropbox/apsr")

### He reads in teh data. 

#bring in data
final<-read.csv("data/sfDataAPSR.csv", stringsAsFactors = F)

### He divides the data into owners and renters. 

owners<-subset(final, ownership_dummy==1)
renters<-subset(final, ownership_dummy==0)

### He creates a control group among home-owners and renters. 

#experiment randomization
control<-subset(final, version==5 | version==6)
control_owners<-subset(control, ownership_dummy==1)
control_renters<-subset(control, ownership_dummy==0)

### Within each group he calculates the percentage of support for increased city-wide housing. 

#percent support
table(control_owners$ten_plan_dummy)
87/(87+33) #.73
table(control_renters$ten_plan_dummy)
171/(32+171) #.84

### Next section goes into creating a figure that depicts support levels for each group. 
### He first splits into groups based on whether or not they would supporta macro-level ban on more housing. 
 
# Figure 1. Support for Micro-scale Ban by Support for Macro-scale Supply ####
control_owners_yes<-subset(control_owners, ten_plan_dummy==1)
control_owners_no<-subset(control_owners, ten_plan_dummy==0)

### He does this for owners and renters alike. 

control_renters_yes<-subset(control_renters, ten_plan_dummy==1)
control_renters_no<-subset(control_renters, ten_plan_dummy==0)

### He calculates the percentage of owners and renters (who support and oppose macro-level supply increase) who support micro-scale ban. 

table(control_owners_yes$prop_i_ban_dummy)
29/(29+49) #.37
table(control_owners_no$prop_i_ban_dummy)
15/30 #.50

table(control_renters_yes$prop_i_ban_dummy)
79/(79+73) #.52
table(control_renters_no$prop_i_ban_dummy)
22/(22+5) #.81

### He defines the levels of support and creates vectors with appropriate names for the groups he's been working with. 

support<-c(.37, .50, .52, .81)
Tenant<-c("Homeowners", "Homeowners", "Renters", "Renters")
supply<-c("Pro-Supply", "Anti-Supply","Pro-Supply","Anti-Supply")
supply<-factor(supply, levels=c("Pro-Supply", "Anti-Supply"))

### He puts the vectors together into a dataframe. 

ban_plot<-data.frame(Tenant, support, supply)

### He creates a figure to depict the dataframe using ggplot function

# Figure
exitpoll_ban<-ggplot(data=ban_plot, aes(x=Tenant, y=support, fill=Tenant))+
  geom_bar(colour="black",stat="identity", position=position_dodge()) + facet_wrap(~supply) +
  ylab("Support (Percent)") + theme(legend.position="none") +ggtitle( "Support for Micro-scale Ban by Support for Macro-scale Supply")+
  theme_bw()+scale_fill_grey()
exitpoll_ban
pdf("plots/Fig1_exitpoll_ban.pdf", height=3, width=6)
plot(exitpoll_ban)
dev.off()

### He uses tiff to improve image quality. 

tiff("plots/Fig1_exitpoll_ban.tif", res=600, compression="lzw", height=3, width=6, units="in")
print(exitpoll_ban)
dev.off()

### He creates another table but this time for support of 10% increase in housing citywide. 

# Table A.3: Policy Proposals, SF ####
#model control supply support

### He performs a simple regression of supporting the 10% plan on ownership and extracts the standard error. 

simple_control<-(lm(ten_plan_dummy ~ ownership_dummy, final)); summary(simple_control)
simple_control_se<-sqrt(diag(vcovHC(simple_control, type="HC1")))

### He fits the full model with all covariates and extracts teh standard error. 

full_control<-(lm(ten_plan_dummy ~ ownership_dummy  +  scale(ideology_num) +scale(income_num) + white_dummy  + age+ gender_dummy , control)); summary(full_control)
full_control_se<-sqrt(diag(vcovHC(full_control, type="HC1")))

### He creates the table of results 

# Table - Control Condition
#Supplementary Data
stargazer(simple_control, full_control, title="Ten Percent Supply Increase, San Francisco",  label="ten_pct_dummy",
          dep.var.labels=c("Support Supply Increase"), dep.var.labels.include = F, dev.var.caption="",
          column.labels=c("Bivariate", "Full"),
          covariate.labels=c("Homeownership","Ideology","Income, Log","White, Non-Hispanic","Age","Male"),
          omit.stat=c("ser","f"), digits=2, align=T,
          initial.zero = F, font.size="small", star.cutoffs = NA, omit.table.layout="n",
          se=list(simple_control_se, full_control_se), no.space=T, omit=c("name"))

### He calculates among all of the respondants percentage of each that support micro-scale ban. 

#Ban within all
table(owners$prop_i_ban_dummy)
187/(281+187) #.40

table(renters$prop_i_ban_dummy)
508/(318+508) #.62

### He does the same thing as above but on the full data set.

#model ban
simple_prop_i_ban<-(lm(prop_i_ban_dummy ~ ownership_dummy  , final)); summary(simple_prop_i_ban)
simple_prop_i_ban_se<-sqrt(diag(vcovHC(simple_prop_i_ban, type="HC1")))

full_prop_i_ban<-(lm(prop_i_ban_dummy ~ ownership_dummy  +  scale(ideology_num) +scale(income_num) + white_dummy  + age+ gender_dummy , final)); summary(full_prop_i_ban)
full_prop_i_ban_se<-sqrt(diag(vcovHC(full_prop_i_ban, type="HC1")))

#Table. Ban support
stargazer(simple_prop_i_ban, full_prop_i_ban, title="Neighborhood Ban, San Francisco",  label="prop_i_ban_dummy",
          dep.var.labels=c("Support Supply Increase"), dep.var.labels.include = F, dev.var.caption="",
          column.labels=c("Bivariate", "Full"),
          covariate.labels=c("Homeownership","Ideology","Income, Log","White, Non-Hispanic","Age","Male"),
          omit.stat=c("ser","f"), digits=2, align=T,
          initial.zero = F, font.size="small", star.cutoffs = NA, omit.table.layout="n",
          se=list(simple_prop_i_ban_se, full_prop_i_ban_se), no.space=T, omit=c("name"))

# Table. Combine these two tables
stargazer(simple_control, full_control, simple_prop_i_ban, full_prop_i_ban, title="Policy Proposals, San Francisco Sample",  label="sf_policies",
          dep.var.labels.include = F, dev.var.caption="",
          column.labels=c("10 Pct Supply", "NIMBY Ban Proposal" ), column.separate = c(2, 2),
          covariate.labels=c("Homeownership","Ideology","Income, Log","White, Non-Hispanic","Age","Male"),
          omit.stat=c("ser","f"), digits=2, align=T, type="text",
          initial.zero = F, font.size="small", star.cutoffs = NA, omit.table.layout="n",
          se=list(simple_control_se, full_control_se, simple_prop_i_ban_se, full_prop_i_ban_se), no.space=T )



```

